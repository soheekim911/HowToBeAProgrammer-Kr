# 성능 문제를 이해하는 법
[//]: # (Version:1.0.0)
디버깅을 배우는 것처럼 실행 중인 시스템의 성능을 이해하는 법을 배우는 것은 피할 수 없는 일입니다. 당신이 쓴 코드의 비용을 완벽하게 정확히 이해하고 있다고 하더라도, 그 코드는 당신에게 통제권이나 가시성이 거의 없는 소프트웨어 시스템을 호출할 수 있습니다. 그러나, 현실에서 성능 문제는 일반적인 디버깅과 조금 다르고 조금 더 쉽습니다.

당신이나 당신의 고객이 시스템이나 하부시스템이 너무 느리게 여긴다고 가정해 봅시다. 그걸 더 빠르게 하기 전에, 왜 그것이 느린지에 대한 멘탈 모델을 세워야만 합니다. 이를 위해 프로파일링 도구나 (잘 기록된) 로그를 사용해서 시간이나 다른 리소스가 정말로 어디에 사용되고 있는지를 찾아낼 수 있습니다. '10%의 코드가 90%의 시간을 잡아먹는다'는 유명한 격언이 있습니다. 대개 대부분의 시간은 어떤 식으로든 I/O에서 사용됩니다. 값비싼 I/O나 10%의 비싼 코드를 찾아내는 것은 멘탈 모델을 만드는 좋은 첫번째 스텝입니다. 

컴퓨터 시스템의 성능에는 많은 차원이 존재하며, 많은 리소스가 소비됩니다. 측정해야 하는 첫번째 리소스는 *벽시계 시간(wall-clock time)*, 계산하는 동안 걸리는 총 시간입니다. *벽시계 시간*을 로깅하는 것은 다른 프로파일링이 비현실적인 상황에서 생기는 예측불가능한 환경에 대해 알려준다는 점에서 특히 귀중합니다. 하지만, 이것이 항상 모든 것을 알려주지는 않습니다. 때로  당신이 실제로 접할 컴퓨팅 환경에서 시간은 조금 더 걸리지만 프로세서를 많이 소모하지 않는 것이 훨씬 나을 수도 있습니다. 비슷하게, 메모리, 네트워크 대역폭, 데이터베이스 혹은 다른 서버 접근이 결론적으로는 프로세서 사용량보다 훨씬 비쌀 수도 있습니다.

동기화된 공유 리소스에 대한 경합은 교착 상태나 결핍을 만들어낼 수도 있습니다. 교착 상태(Contention)는 부적절한 동기화나 리소스 요구 때문에 진행이 불가능해지는 것입니다. 결핍(Starvation)은 구성요소를 적절하게 계획하는 데에 실패하는 것입니다. 이 모든 것이 예상 가능하다면, 프로젝트를 시작할 때부터 이러한 경합을 측정하는 방법을 두는 것이 최선입니다. 경합이 일어나지 않더라도, 자신감을 가지고 어설션할 수 있는 것은 매우 도움이 됩니다. 

다음 장 [성능 문제를 해결하는 방법](06-How-to-Fix-Performance-Problems.md)
