# 성능 문제를 해결하기
[//]: # (Version:1.0.0)
대부분의 소프트웨어 프로젝트는 상대적으로 적은 노력으로도 처음 릴리스 되었을 때보다 10배에서 100배가량 빠르게 작동하도록 만들어질 수 있습니다. 시장 출시일에 대한 압박 속에서는 작업을 단순하고 빠르게 끝낼 수 있는 해결책을 선택하는 것이 현명하면서도 효과적이지만, 다른 어떤 해결책들에 비해서는 덜 효율적이기도 합니다. 하지만, 성능 또한 사용성의 일부이며, 결국에는 더 신중하게 고려되어야 하는 경우가 많습니다.

매우 복잡한 시스템의 성능을 향상시키는 핵심은 그것을 충분히 분석해서 *병목 상태*, 즉 대부분의 리소스가 소비되는 지점을 찾는 것입니다. 계산 시간의 고작 1%를 차지하는 함수를 최적화하는 것은 큰 의미가 없습니다. 엄지의 법칙(rule of thumb)에 따라, 당신은 지금 하려는 것이 시스템 전체 혹은 대부분을 최소한 2배 이상 빠르게 만들 수 있는 것인지에 대해 신중하게 생각해보아야 합니다. 이를 위해 통상적으로 사용하는 방법이 있습니다. 당신이 만든 변화로 인해 필요한 테스트와 품질 보증에 드는 노력을 생각해보세요. 변경은 매번 테스트해야 하는 부담을 주기 때문에, 큰 변경을 가끔 하는 편이 훨씬 낫습니다.

당신이 두 배 이상의 성능 향상을 가져왔다면, 시스템에서 다음으로 가장 큰 병목 상태를 생각하거나 다시 분석해서, 다시 두 배의 성능 향상을 가져올 수 있도록 공략합니다.

자주, 성능의 병목 현상은 소를 셀 때 머리를 세는 대신 다리를 센 후 4로 나누는 방식과 같이 일어납니다. 예를 들어, 관계형 데이터베이스 시스템에서 자주 조회하는 칼럼에 적절한 인덱스를 부여하지 않아서 아마도 최소 20배 이상 느려지게 만드는 에러를 만든 적이 있습니다. 또 다른 예시로는 내부 루프에서 불필요한 I/O를 하거나, 디버깅할 때 사용한 더는 필요하지 않은 코드를 남겨놓거나, 불필요한 메모리 할당, 성능에 관해서는 문서화가 거의 되어 있지 않은 라이브러리나 하위 시스템을 미숙하게 사용하는 경우 등이 있습니다. 이런 종류의 성능 향상은 *낮게 달린 과일*이라 불리는데, 쉽게 딸 수 있으면서 상당한 이점을 주기 때문입니다.

낮게 달린 과일이 거의 남지 않았을 때쯤엔 뭘 해야 하냐고요? 글쎄요, 더 높은 곳으로 손을 뻗거나 나무를 베어낼 수도 있겠죠. 작은 성능 향상을 계속 이루거나 시스템이나 하위 시스템을 진지하게 다시 설계할 수도 있습니다(이는 새로운 디자인뿐만 아니라 당신의 상사에게 이게 좋은 아이디어임을 설득해야 한다는 점에서 좋은 프로그래머가 되기 위한 스킬을 쌓을 멋진 기회입니다). 그러나, 하위 시스템을 재설계를 주장하기 전에, 그 제안이 그것을 다섯 배에서 열 배 더 낫게 만들 수 있을지에 대해 자문해보아야 할 것입니다.

다음 장 [루프를 최적화하는 방법](02-How-to-Optimize-Loops.md)
